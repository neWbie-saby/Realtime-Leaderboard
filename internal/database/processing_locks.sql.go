// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: processing_locks.sql

package database

import (
	"context"
)

const acquireLock = `-- name: AcquireLock :execrows
INSERT INTO processing_locks (resource_type, resource_id, locked_by, expires_at, released_at)
VALUES ($1, $2, $3, NOW() + INTERVAL '5 minute', NULL)
ON CONFLICT (resource_type, resource_id) WHERE released_at IS NULL DO NOTHING
`

type AcquireLockParams struct {
	ResourceType string
	ResourceID   string
	LockedBy     string
}

func (q *Queries) AcquireLock(ctx context.Context, arg AcquireLockParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, acquireLock, arg.ResourceType, arg.ResourceID, arg.LockedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteExpiredLocks = `-- name: DeleteExpiredLocks :execrows
DELETE FROM processing_locks
WHERE expires_at <= NOW() AND released_at IS NULL
`

func (q *Queries) DeleteExpiredLocks(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteExpiredLocks)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const releaseLock = `-- name: ReleaseLock :exec
UPDATE processing_locks 
SET released_at = NOW()
WHERE resource_type = $1
AND resource_id = $2
AND locked_by = $3
`

type ReleaseLockParams struct {
	ResourceType string
	ResourceID   string
	LockedBy     string
}

func (q *Queries) ReleaseLock(ctx context.Context, arg ReleaseLockParams) error {
	_, err := q.db.ExecContext(ctx, releaseLock, arg.ResourceType, arg.ResourceID, arg.LockedBy)
	return err
}
