// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: match_users.sql

package database

import (
	"context"
)

const addUserToMatch = `-- name: AddUserToMatch :exec
INSERT INTO match_users (match_id, user_id, score)
VALUES ($1, $2, $3)
`

type AddUserToMatchParams struct {
	MatchID int32
	UserID  int32
	Score   int32
}

func (q *Queries) AddUserToMatch(ctx context.Context, arg AddUserToMatchParams) error {
	_, err := q.db.ExecContext(ctx, addUserToMatch, arg.MatchID, arg.UserID, arg.Score)
	return err
}

const getMatchUserScores = `-- name: GetMatchUserScores :many
SELECT user_id, score FROM match_users WHERE match_id = $1
`

type GetMatchUserScoresRow struct {
	UserID int32
	Score  int32
}

func (q *Queries) GetMatchUserScores(ctx context.Context, matchID int32) ([]GetMatchUserScoresRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchUserScores, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchUserScoresRow
	for rows.Next() {
		var i GetMatchUserScoresRow
		if err := rows.Scan(&i.UserID, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchUserScoresAndUserNames = `-- name: GetMatchUserScoresAndUserNames :many
SELECT u.id, u.username, mu.score 
FROM match_users mu 
JOIN users u ON u.id = mu.user_id 
WHERE mu.match_id = $1
`

type GetMatchUserScoresAndUserNamesRow struct {
	ID       int32
	Username string
	Score    int32
}

func (q *Queries) GetMatchUserScoresAndUserNames(ctx context.Context, matchID int32) ([]GetMatchUserScoresAndUserNamesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMatchUserScoresAndUserNames, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMatchUserScoresAndUserNamesRow
	for rows.Next() {
		var i GetMatchUserScoresAndUserNamesRow
		if err := rows.Scan(&i.ID, &i.Username, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchUserExists = `-- name: MatchUserExists :one
SELECT EXISTS (
    SELECT 1 FROM match_users WHERE user_id = $1 AND match_id = $2
)
`

type MatchUserExistsParams struct {
	UserID  int32
	MatchID int32
}

func (q *Queries) MatchUserExists(ctx context.Context, arg MatchUserExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, matchUserExists, arg.UserID, arg.MatchID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateUserScoreOnMatch = `-- name: UpdateUserScoreOnMatch :exec
UPDATE match_users
SET score = $1
WHERE user_id = $2 AND match_id = $3
`

type UpdateUserScoreOnMatchParams struct {
	Score   int32
	UserID  int32
	MatchID int32
}

func (q *Queries) UpdateUserScoreOnMatch(ctx context.Context, arg UpdateUserScoreOnMatchParams) error {
	_, err := q.db.ExecContext(ctx, updateUserScoreOnMatch, arg.Score, arg.UserID, arg.MatchID)
	return err
}
